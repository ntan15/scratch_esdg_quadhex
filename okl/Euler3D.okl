#if USE_DOUBLE
#define dfloat double
#define dfloat4 double4
#define LOGDF log
#define POWDF pow
#define EXPDF exp
#else
#define dfloat float
#define dfloat4 float4
#define LOGDF logf
#define POWDF powf
#define EXPDF expf
#endif

#define PARALLEL_DIM
#define NUM_THREADS 192

// helpful functions
#define avg(a, b) .5f * (a + b)
#define pfun(rho, u, v, w, E)					\
  ((p_gamma - 1.f) * (E - .5f * rho * (u * u + v * v + w * w)))
#define beta(rho, u, v, w, E)				\
  (rho / (2.f * pfun(rho, u, v, w, E))) // inverse temp
#define beta_test(rho, u, v, w, E)                                             \
  ((rho*rho) / (2.f * ((p_gamma - 1.f) * ((rho * E) - .5f *                    \
  (u * u + v * v + w * w)))))

// map conservation to entropy vars
#define pfun(rho, u, v, w, E)					\
  ((p_gamma - 1.f) * (E - .5f * rho * (u * u + v * v + w * w)))
#define rhoeU(rho, rhou, rhov, rhow, E)				\
  (E - .5f * (rhou * rhou + rhov * rhov + rhow * rhow) / rho)
#define sU(rho, rhou, rhov, rhow, E)				\
  (LOGDF((p_gamma - 1.f) * rhoeU(rho, rhou, rhov, rhow, E) /	\
         POWDF(rho, p_gamma)))

// map entropy to conservation vars
#define sV(V1, V2, V3, V4, V5)					\
  (p_gamma - V1 + (V2 * V2 + V3 * V3 + V4 * V4) / (2.f * V5))
#define rhoeV(V1, V2, V3, V4, V5)					\
  (POWDF((p_gamma - 1.f) / POWDF(-V5, p_gamma), 1.f / (p_gamma - 1.f)) * \
   EXPDF(-sV(V1, V2, V3, V4, V5) / (p_gamma - 1.f)))

// occa function
dfloat logmean(dfloat aL, dfloat aR)
{
  const dfloat xi = aL / aR;
  const dfloat f = (xi - 1.f) / (xi + 1.f);
  const dfloat u = f * f;
  const dfloat u2 = u * u;

  dfloat F = .5f * LOGDF(xi) / f; // Log(xi) = Log(aL)-log(aR) 
  if (fabs(u) < 1.fe-4)
    {
      //F = 1.f + u / 3.f + u2 / 5.f + u2 * u / 7.f;
      F = 1.f + .333333333333333f * u + .2f * u2 + 0.142857142857143f * u2 * u;
    }
  return .5f * (aL + aR) / F;

}

dfloat logmean_test(dfloat aL, dfloat aR)
{
  const dfloat xi = aL / aR;
  const dfloat f = (xi - 1.f) / (xi + 1.f);
  const dfloat u = f * f;
  const dfloat u2 = u * u;

  if (fabs(u) < 1.fe-4)
  {
    dfloat F = 105.f + 35.f * u + 21.f * u2 + 15.f * u2 * u;
    return 52.5f * (aL + aR) / F;
  } else {
    return f * (aL + aR) / LOGDF(xi);
  }

}

void VU(dfloat rho, dfloat rhou, dfloat rhov, dfloat rhow, dfloat E,
	dfloat &V1, dfloat &V2, dfloat &V3, dfloat &V4, dfloat &V5)
{

  const dfloat rhoe = rhoeU(rho, rhou, rhov, rhow, E);
  const dfloat invrhoe = 1.f/rhoe;
  V1 = (-E + rhoe * (p_gamma + 1.f - sU(rho, rhou, rhov, rhow, E))) * invrhoe;
  V2 = rhou * invrhoe;
  V3 = rhov * invrhoe;
  V4 = rhow * invrhoe;
  V5 = (-rho) * invrhoe;
}

void UV(dfloat V1, dfloat V2, dfloat V3, dfloat V4, dfloat V5,
	dfloat &rho, dfloat &rhou, dfloat &rhov, dfloat &rhow, dfloat &E)
{

  const dfloat rhoe = rhoeV(V1, V2, V3, V4, V5);
  rho = rhoe * (-V5);
  rhou = rhoe * (V2);
  rhov = rhoe * (V3);
  rhow = rhoe * (V4);
  E = rhoe * (1.f - (V2 * V2 + V3 * V3 + V4 * V4) / (2.f * V5));
}

void euler3d_flux(dfloat rho_i, dfloat rho_j, dfloat u_i, dfloat u_j,
		  dfloat v_i, dfloat v_j, dfloat w_i, dfloat w_j, dfloat E_i,
		  dfloat E_j, dfloat beta_i, dfloat beta_j, dfloat *FxS,
		  dfloat *FyS, dfloat *FzS)
{

  const dfloat rholog = logmean(rho_i, rho_j);
  const dfloat rhoavg = avg(rho_i, rho_j);
  const dfloat uavg = avg(u_i, u_j);
  const dfloat vavg = avg(v_i, v_j);
  const dfloat wavg = avg(w_i, w_j);
  const dfloat vnavg = 2.f * (uavg * uavg + vavg * vavg + wavg * wavg) -
    (avg(u_i * u_i, u_j * u_j) + avg(v_i * v_i, v_j * v_j) +
     avg(w_i * w_i, w_j * w_j));
  const dfloat beta_avg = avg(beta_i, beta_j);

  const dfloat pa = rhoavg / (2.f * beta_avg);
  const dfloat f4aux =
    rholog / (2.f * (p_gamma - 1.f) * logmean(beta_i, beta_j)) + pa +
    .5f * rholog * vnavg;

  FxS[0] = rholog * uavg;
  FyS[0] = rholog * vavg;
  FzS[0] = rholog * wavg;

  FxS[1] = FxS[0] * uavg + pa;
  FyS[1] = FyS[0] * uavg;
  FzS[1] = FzS[0] * uavg;

  FxS[2] = FxS[0] * vavg;
  FyS[2] = FyS[0] * vavg + pa;
  FzS[2] = FzS[0] * vavg;

  FxS[3] = FxS[0] * wavg;
  FyS[3] = FyS[0] * wavg;
  FzS[3] = FzS[0] * wavg + pa;

  FxS[4] = f4aux * uavg;
  FyS[4] = f4aux * vavg;
  FzS[4] = f4aux * wavg;

#define testGCL 0
#if testGCL
  // for testing GCL
  FxS[0] = 1.0;
  FyS[0] = 1.0;
  FzS[0] = 1.0;	    
#endif 
}

void euler3d_flux_test(dfloat rho_i, dfloat rho_j, dfloat u_i, dfloat u_j,
		  dfloat v_i, dfloat v_j, dfloat w_i, dfloat w_j, dfloat E_i,
		  dfloat E_j, dfloat beta_i, dfloat beta_j, dfloat* FxS, dfloat* FyS, dfloat* FzS)
{

  const dfloat rholog = logmean_test(rho_i, rho_j);
  const dfloat rhoavg = avg(rho_i, rho_j);
  const dfloat uavg = avg(u_i, u_j);
  const dfloat vavg = avg(v_i, v_j);
  const dfloat wavg = avg(w_i, w_j);
  const dfloat vnavg = 2.f * (uavg * uavg + vavg * vavg + wavg * wavg) -
    (avg(u_i * u_i, u_j * u_j) + avg(v_i * v_i, v_j * v_j) +
     avg(w_i * w_i, w_j * w_j));
  const dfloat beta_avg = avg(beta_i, beta_j);

  const dfloat pa = rhoavg / (2.f * beta_avg);
  const dfloat f4aux =
    rholog / (2.f * (p_gamma - 1.f) * logmean_test(beta_i, beta_j)) + pa +
    .5f * rholog * vnavg;

//  const dfloat v0 = rholog * (x*uavg + y*vavg + z*wavg);

  FxS[0] = rholog * uavg;
  FyS[0] = rholog * vavg;
  FzS[0] = rholog * wavg;

//  val[0] += v0;

  FxS[1] = FxS[0] * uavg + pa;
  FyS[1] = FyS[0] * uavg;
  FzS[1] = FzS[0] * uavg;
//  val[1] += uavg * v0 + x*pa;

  FxS[2] = FxS[0] * vavg;
  FyS[2] = FyS[0] * vavg + pa;
  FzS[2] = FzS[0] * vavg;
//  val[2] += vavg * v0 + y*pa;

  FxS[3] = FxS[0] * wavg;
  FyS[3] = FyS[0] * wavg;
  FzS[3] = FzS[0] * wavg + pa;
//  val[3] += wavg * v0 + z*pa;

  FxS[4] = f4aux * uavg;
  FyS[4] = f4aux * vavg;
  FzS[4] = f4aux * wavg;
//  val[4] += f4aux * (x*uavg + y*vavg + z*wavg);

#define testGCL 0
#if testGCL
  // for testing GCL
  FxS[0] = 1.0;
  FyS[0] = 1.0;
  FzS[0] = 1.0;	    
#endif 
}


// initialize surface values from interior
@kernel void eval_surface(const int K,
			  const dfloat * Vf1D,
			  const dfloat * Q,
			  dfloat * Qf){
  for (int e = 0; e < K; ++e; @outer(0)){

    @shared dfloat s_Vf[p_Nq1]; // second col is symmetric
    @shared dfloat s_V[p_Nfields][p_Nq1][p_Nq1][p_Nq1]; // entropy vars
    
    for (int i = 0; i < p_T; ++i; @inner(0)){
      if (i < p_Nq1){
	      s_Vf[i] = Vf1D[i];	
      }
      
      if (i < p_Nq3){
        // load vol values
        const int kk = i / p_Nq2;
        const int ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        const int jj = i % p_Nq1; // x-id

        int id = i + p_Nq3 * p_Nfields * e;
        const dfloat rho  = Q[id]; id += p_Nq3;
        const dfloat rhou = Q[id]; id += p_Nq3;
        const dfloat rhov = Q[id]; id += p_Nq3;
        const dfloat rhow = Q[id]; id += p_Nq3;	
        const dfloat E    = Q[id];
        
        // evaluate entropy vars at nodes
        dfloat V1,V2,V3,V4,V5;
        VU(rho, rhou, rhov, rhow, E, V1, V2, V3, V4, V5);

        //	if (e==0){
        //	  printf("V1-V4(%d) = %f, %f, %f, %f\n",i,V1,V2,V3,V4);
        //	}
        s_V[0][ii][jj][kk] = V1;
        s_V[1][ii][jj][kk] = V2;
        s_V[2][ii][jj][kk] = V3;
        s_V[3][ii][jj][kk] = V4;
        s_V[4][ii][jj][kk] = V5;
      }
    }

    @barrier("localMemFence");

    for (int i = 0; i < p_T; ++i; @inner(0)){
      if (i < p_NfpNfaces){

        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;
        
        dfloat V1f = 0.f;
        dfloat V2f = 0.f;
        dfloat V3f = 0.f;
        dfloat V4f = 0.f;
        dfloat V5f = 0.f;		
        for (int j = 0; j < p_Nq1; ++j){	  

          int Vfjid, idi, idj, idk;
          Vfjid = (f % 2 == 0) ? j : p_Nq1-j-1; // traverse forwards/backwards
          if (f==0 || f==1){ // -/+ r
            // local coords = s, t
            idi = j;
            idj = fid1;
            idk = fid2;
          }else if (f==2 || f==3){ // -/+ s
            //local coords r,t     
            idi = fid1;
            idj = j;
            idk = fid2; 	    
          }else if (f==4 || f==5){ // -/+ t
            // local coords r,s
            idi = fid1;
            idj = fid2;
            idk = j;
            //printf("f = %d, idijk = %d, %d, %d\n",f,idi,idj,idk);
          }

          // interp left/right in r direction
          const dfloat Vfj = s_Vf[Vfjid];
          V1f += Vfj * s_V[0][idi][idj][idk]; 
          V2f += Vfj * s_V[1][idi][idj][idk];
          V3f += Vfj * s_V[2][idi][idj][idk];
          V4f += Vfj * s_V[3][idi][idj][idk];
          V5f += Vfj * s_V[4][idi][idj][idk];	  
        }

        dfloat rhof, rhouf, rhovf, rhowf, Ef;
        UV(V1f,V2f,V3f,V4f,V5f, rhof, rhouf, rhovf, rhowf, Ef); 

        int id = i + e*p_NfpNfaces*p_Nfields;
        Qf[id] = rhof;   id += p_NfpNfaces;
        Qf[id] = rhouf;  id += p_NfpNfaces;
        Qf[id] = rhovf;  id += p_NfpNfaces;
        Qf[id] = rhowf;  id += p_NfpNfaces;	
        Qf[id] = Ef;	

        //printf("Qf(%d) = %f, %f, %f, %f, %f\n",i,rhof,rhouf,rhovf,rhowf,Ef);
	
      }      
    } // inner0
  }
}

@kernel void volume(const int K,
		    const dfloat *  vgeo,
		    const dfloat *  vfgeo,
		    const dfloat *  D1D,
		    const dfloat *  Vf1D,
		    const dfloat *  Lf1D,		    
		    const dfloat *  Q,
		    dfloat *  Qf,
		    dfloat *  rhs,
		    dfloat *  rhsf){

  for (int e = 0; e < K; ++e; @outer(0)){

    @shared dfloat s_D[p_Nq1][p_Nq1];
    @shared dfloat s_Lf[p_Nq1];
    @shared dfloat s_Vf[p_Nq1];        

    @shared dfloat s_Q[p_Nfields][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_Qf[p_Nfields][p_Nfaces][p_Nq1][p_Nq1];

    @shared dfloat s_G[p_Nvgeo][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_Gf[p_Nvgeo][p_Nfaces][p_Nq1][p_Nq1];    

    @exclusive int ii,jj,kk;
   
    for (int i = 0; i < p_T; ++i; @inner(0)){

      // load ops
      if (i < p_Nq1){
      	s_Lf[i] = Lf1D[i];
      	s_Vf[i] = Vf1D[i];
      }           
      if (i < p_Nq2){
      	const int id1 = i % p_Nq1;
      	const int id2 = i / p_Nq1;
      	s_D[id1][id2] = D1D[i]; // i < (N+1)^2 = size of D1D
      }
      
      if (i < p_Nq3){
		
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id

        // load geofacs
        int id = i + p_Nq3 * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_G[geo][ii][jj][kk] = vgeo[id];
          id += p_Nq3;
        }

        // load vol values
        id = i + p_Nq3 * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Q[fld][ii][jj][kk] = Q[id];
          id += p_Nq3;
        }
      }

      // load surface geo
      if (i < p_NfpNfaces){
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;
        
        int id = i + p_NfpNfaces * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_Gf[geo][f][fid1][fid2] = vfgeo[id];
          id += p_NfpNfaces;
        }

        int idf = i + p_NfpNfaces * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Qf[fld][f][fid1][fid2] = Qf[idf];
          idf += p_NfpNfaces;
        }       
      }      
    }
    @barrier("localMemFence");

    // differentiate fluxes
    for (int i = 0; i < p_T; ++i; @inner(0)){

      if (i < p_Nq3){

        // recompute IJK (occa issue)
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id
        
        dfloat val[p_Nfields] = {0};

        const dfloat rho_i = s_Q[0][ii][jj][kk];
        const dfloat inv_rho_i = 1.f/rho_i;
        const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
        const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
        const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
        const dfloat E_i = s_Q[4][ii][jj][kk];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        // start loop over dimensions		
        dfloat gxi,gyi,gzi;
        int idi,idj,idk,idout;

        for (int dim = 0; dim < 3; ++dim){
        
          const int geoid = 3*dim;	
          idi = ii;  idj = jj;  idk = kk;
          
          // diff in "dim" direction
          gxi = s_G[geoid][ii][jj][kk];
          gyi = s_G[geoid+1][ii][jj][kk];
          gzi = s_G[geoid+2][ii][jj][kk];

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

          // differentiate w.r.t one coordinate
          for (int j = 0; j < p_Nq1; ++j){
            if (dim==0){
              idi = j;  idout = ii;
            }else if (dim==1){
              idj = j;  idout = jj;	  	      
            }else if (dim==2){
              idk = j;  idout = kk;
            }
            
            const dfloat gxj = s_G[geoid][idi][idj][idk];
            const dfloat gyj = s_G[geoid+1][idi][idj][idk];
            const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
            
            const dfloat rho_j = s_Q[0][idi][idj][idk];
            const dfloat inv_rho_j = 1.f/rho_j;
            const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
            const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
            const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
            const dfloat E_j = s_Q[4][idi][idj][idk];	  
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
            
            const dfloat Dij = s_D[idout][j]; // ii,jj = which line of nodes
            
            const dfloat Dx = Dij * .5f*(gxi + gxj);
            const dfloat Dy = Dij * .5f*(gyi + gyj);
            const dfloat Dz = Dij * .5f*(gzi + gzj);	  

            euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
            val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
            val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
            val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
            val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

/*
            euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            const dfloat Dij = s_D[idout][j]; // ii,jj = which line of nodes
            
            const dfloat Dx = Dij * .5f*(gxi + gxj);
            const dfloat Dy = Dij * .5f*(gyi + gyj);
            const dfloat Dz = Dij * .5f*(gzi + gzj);	  
            
            val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
            val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
            val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
            val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
            val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];
*/
          }

          // ============ accum rst = +/- 1 faces, nhat = -/+ 1
          
          // rotate coordinates
          if (dim==0){ // r
            idi = ii;  idj = jj;  idk = kk;
          }else if (dim==1){ // s 
            idi = jj;  idj = ii;  idk = kk;
          }else{ // t 
            idi = kk;  idj = ii;  idk = jj;
          }
          for (int ff = 0; ff < 2; ++ff){
            const int f = 2*dim+ff; 
            const dfloat rho_j = s_Qf[0][f][idj][idk];
            const dfloat inv_rho_j = 1.f/rho_j;
            const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
            const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
            const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
            const dfloat E_j = s_Qf[4][f][idj][idk];
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

            // left vs right face normal vector, index	    
            const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
            const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

            const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
            const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
            const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
            const dfloat Lx = nsgn * geox * s_Lf[lid];
            const dfloat Ly = nsgn * geoy * s_Lf[lid];
            const dfloat Lz = nsgn * geoz * s_Lf[lid];

            euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
            val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
            val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
            val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
            val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
            val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

/*
            euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);

            // left vs right face normal vector, index	    
            const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
            const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

            const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
            const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
            const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
            const dfloat Lx = nsgn * geox * s_Lf[lid];
            const dfloat Ly = nsgn * geoy * s_Lf[lid];
            const dfloat Lz = nsgn * geoz * s_Lf[lid];
          
            val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
            val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
            val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
            val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
            val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];
*/
          }
        } // for dim < 3
        
        int id = i + e*p_Nq3*p_Nfields;
        rhs[id] = val[0]; id += p_Nq3;
        rhs[id] = val[1]; id += p_Nq3;
        rhs[id] = val[2]; id += p_Nq3;
        rhs[id] = val[3]; id += p_Nq3;	
        rhs[id] = val[4];
	
      } // i < p_Nq3      

      if (i < p_NfpNfaces){
	
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;

        dfloat val[p_Nfields] = {0};
/*
        for (int fld = 0; fld < p_Nfields; ++fld){
          val[fld] = 0.f;
        }
*/
        // compute (nhat*Vf).*FS contribution -> rhsf
        const dfloat rho_i = s_Qf[0][f][fid1][fid2];
        const dfloat invrho_i = 1.f/rho_i;
        const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
        const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
        const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
        const dfloat E_i = s_Qf[4][f][fid1][fid2];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
        for (int j = 0; j < p_Nq1; ++j){

          int idi, idj, idk, geoid;
          if (f==0 || f==1){ 
            idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
          }else if (f==2 || f==3){ 
            idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
          }else if (f==4 || f==5){ 
            idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
          }
          const int is_left_face = (f % 2 == 0);
          const dfloat nsgn = is_left_face ? -1.f : 1.f;
          const int jid = is_left_face ? j : p_Nq1-j-1;
          const dfloat Vfj = .5f * nsgn * s_Vf[jid];
          
          const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
          const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
          const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat invrho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                 E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
          val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
          val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
          val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
          val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

/*
          euler3d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                 E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
          val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
          val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
          val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
          val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  
*/
        }

        int id = i + e*p_NfpNfaces*p_Nfields;
        rhsf[id] = -val[0]; id += p_NfpNfaces;
        rhsf[id] = -val[1]; id += p_NfpNfaces;
        rhsf[id] = -val[2]; id += p_NfpNfaces;
        rhsf[id] = -val[3]; id += p_NfpNfaces;	
        rhsf[id] = -val[4]; 	

      }
   	        
    }// inner0

  }
}

@kernel void volume_test(const int K,
		    const dfloat *  vgeo,
		    const dfloat *  vfgeo,
		    const dfloat *  D1D,
		    const dfloat *  Vf1D,
		    const dfloat *  Lf1D,		    
		    const dfloat *  Q,
		    dfloat *  Qf,
		    dfloat *  rhs,
		    dfloat *  rhsf,
        dfloat *  scratch_Nq3,
        dfloat *  scratch_NfpNfaces){
  for (int e = 0; e < K; ++e; @outer(0)){

    @shared dfloat s_D[p_Nq1][p_Nq1];
    @shared dfloat s_Lf[p_Nq1];
    @shared dfloat s_Vf[p_Nq1];        

    @shared dfloat s_Q[p_Nfields][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_Qf[p_Nfields][p_Nfaces][p_Nq1][p_Nq1];

    @shared dfloat s_G[p_Nvgeo][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_Gf[p_Nvgeo][p_Nfaces][p_Nq1][p_Nq1];    

    @shared dfloat s_store_x[p_Nfields][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_store_y[p_Nfields][p_Nq1][p_Nq1][p_Nq1];
    @shared dfloat s_store_z[p_Nfields][p_Nq1][p_Nq1][p_Nq1];

    @shared dfloat storage[p_Nfields][p_Nq1][p_Nq1][p_Nq1];

    @exclusive int ii,jj,kk;

#ifdef PARALLEL_DIM   
//    for (int i = 0; i < 3*p_Nq3+p_NfpNfaces; ++i; @inner(0)){
    for (int i = 0; i < 3*p_Nq3; ++i; @inner(0)){
//    for (int i = 0; i < NUM_THREADS; ++i; @inner(0)){

      // load ops
      if (i < p_Nq1){
      	s_Lf[i] = Lf1D[i];
      	s_Vf[i] = Vf1D[i];
      }           
      if (i < p_Nq2){
      	const int id1 = i % p_Nq1;
      	const int id2 = i / p_Nq1;
      	s_D[id1][id2] = D1D[i]; // i < (N+1)^2 = size of D1D
      }
      
      if (i < p_Nq3){
		
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id

        // load geofacs
        int id = i + p_Nq3 * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_G[geo][ii][jj][kk] = vgeo[id];
          id += p_Nq3;
        }

        // load vol values
        id = i + p_Nq3 * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Q[fld][ii][jj][kk] = Q[id];
          id += p_Nq3;
        }
      }

      // load surface geo
      if (i < p_NfpNfaces){
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;
        
        int id = i + p_NfpNfaces * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_Gf[geo][f][fid1][fid2] = vfgeo[id];
          id += p_NfpNfaces;
        }

        int idf = i + p_NfpNfaces * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Qf[fld][f][fid1][fid2] = Qf[idf];
          idf += p_NfpNfaces;
        }       
      }      
// Set values to zero for atomics
      if (i < p_Nq3){

        int id = i + e*p_Nq3*p_Nfields;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
      }

      if (i < p_NfpNfaces) {
        int id = i + e*p_NfpNfaces*p_Nfields;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
      }

      if(i < p_Nq3) {
        int kk = i / p_Nq2; // z-id
        int ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        int jj = i % p_Nq1; // x-id
        s_store_x[0][ii][jj][kk] = 0.0f;
        s_store_x[1][ii][jj][kk] = 0.0f;
        s_store_x[2][ii][jj][kk] = 0.0f;
        s_store_x[3][ii][jj][kk] = 0.0f;
        s_store_x[4][ii][jj][kk] = 0.0f;

        s_store_y[0][ii][jj][kk] = 0.0f;
        s_store_y[1][ii][jj][kk] = 0.0f;
        s_store_y[2][ii][jj][kk] = 0.0f;
        s_store_y[3][ii][jj][kk] = 0.0f;
        s_store_y[4][ii][jj][kk] = 0.0f;

        s_store_z[0][ii][jj][kk] = 0.0f;
        s_store_z[1][ii][jj][kk] = 0.0f;
        s_store_z[2][ii][jj][kk] = 0.0f;
        s_store_z[3][ii][jj][kk] = 0.0f;
        s_store_z[4][ii][jj][kk] = 0.0f;
      }

    }

@barrier("localMemFence");
/*
    Computes data in all three dimensions with an variable number of threads.
    Must use at least p_NfpNface+3 threads, remaining threads go to speed up
    differentiation for all 3 dimensions. More threads helpful until each
    element gets its own thread.
*/
/*
    for(int i=0; i<NUM_THREADS; ++i; @inner(0)) {
        const int thread_step = (NUM_THREADS-p_NfpNfaces)/3;
        if(i < thread_step) {
            for(int tid=i; tid < p_Nq3; tid=tid+thread_step) {
// Dim 0
                // recompute IJK (occa issue)
                kk = tid / p_Nq2; // z-id
                ii = (tid - kk*p_Nq2) / p_Nq1; // y-id
                jj = tid % p_Nq1; // x-id
                
                dfloat val[p_Nfields] = {0};

                const dfloat rho_i = s_Q[0][ii][jj][kk];
                const dfloat inv_rho_i = 1.f/rho_i;
                const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
                const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
                const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
                const dfloat E_i = s_Q[4][ii][jj][kk];
                const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

                // start loop over dimensions		
                dfloat gxi,gyi,gzi;
                int idi,idj,idk,idout;

                const int geoid = 0;	
                idi = ii;  idj = jj;  idk = kk;
                
                // diff in "dim" direction
                gxi = s_G[geoid][ii][jj][kk];
                gyi = s_G[geoid+1][ii][jj][kk];
                gzi = s_G[geoid+2][ii][jj][kk];

                dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

                // differentiate w.r.t one coordinate
                for (int j = 0; j < p_Nq1; ++j){
//                idi = j;  idout = ii;
                  
                  const dfloat gxj = s_G[geoid][j][idj][idk];
                  const dfloat gyj = s_G[geoid+1][j][idj][idk];
                  const dfloat gzj = s_G[geoid+2][j][idj][idk];	  
                  
                  const dfloat rho_j = s_Q[0][j][idj][idk];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Q[1][j][idj][idk] * inv_rho_j;
                  const dfloat v_j = s_Q[2][j][idj][idk] * inv_rho_j;
                  const dfloat w_j = s_Q[3][j][idj][idk] * inv_rho_j;	  
                  const dfloat E_j = s_Q[4][j][idj][idk];	  
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
                  
                  const dfloat Dij = s_D[ii][j]; // ii,jj = which line of nodes
                  
                  const dfloat Dx = Dij * .5f*(gxi + gxj);
                  const dfloat Dy = Dij * .5f*(gyi + gyj);
                  const dfloat Dz = Dij * .5f*(gzi + gzj);	  

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                  
                  val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
                  val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
                  val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
                  val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
                  val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

                }

                // ============ accum rst = +/- 1 faces, nhat = -/+ 1
                
                // rotate coordinates
                // r
                idi = ii;  idj = jj;  idk = kk;
                for (int ff = 0; ff < 2; ++ff){
                  const int f = ff; 
                  const dfloat rho_j = s_Qf[0][f][idj][idk];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
                  const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
                  const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
                  const dfloat E_j = s_Qf[4][f][idj][idk];
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

                  // left vs right face normal vector, index	    
                  const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
                  const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

                  const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
                  const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
                  const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
                  const dfloat Lx = nsgn * geox * s_Lf[lid];
                  const dfloat Ly = nsgn * geoy * s_Lf[lid];
                  const dfloat Lz = nsgn * geoz * s_Lf[lid];

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                
                  val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
                  val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
                  val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
                  val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
                  val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

                }

                int rhsid = tid + e*p_Nq3*p_Nfields;
                atomicAdd(&(rhs[rhsid]), val[0]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[1]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[2]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[3]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[4]);
            }
        } else if(i < 2*thread_step) {
            for(int tid=(i-thread_step); tid < p_Nq3; tid=tid+thread_step) {
// Dim 1
                // recompute IJK (occa issue)
                kk = tid / p_Nq2; // z-id
                ii = (tid - kk*p_Nq2) / p_Nq1; // y-id
                jj = tid % p_Nq1; // x-id
                
                dfloat val[p_Nfields] = {0};

                const dfloat rho_i = s_Q[0][ii][jj][kk];
                const dfloat inv_rho_i = 1.f/rho_i;
                const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
                const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
                const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
                const dfloat E_i = s_Q[4][ii][jj][kk];
                const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

                // start loop over dimensions		
                dfloat gxi,gyi,gzi;
                int idi,idj,idk,idout;

                const int geoid = 3;	
                idi = ii;  idj = jj;  idk = kk;
                
                // diff in "dim" direction
                gxi = s_G[geoid][ii][jj][kk];
                gyi = s_G[geoid+1][ii][jj][kk];
                gzi = s_G[geoid+2][ii][jj][kk];

                dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

                // differentiate w.r.t one coordinate
                for (int j = 0; j < p_Nq1; ++j){
            //      idj = j;  idout = jj;	  	      
                  
                  const dfloat gxj = s_G[geoid][idi][j][idk];
                  const dfloat gyj = s_G[geoid+1][idi][j][idk];
                  const dfloat gzj = s_G[geoid+2][idi][j][idk];	  
                  
                  const dfloat rho_j = s_Q[0][idi][j][idk];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Q[1][idi][j][idk] * inv_rho_j;
                  const dfloat v_j = s_Q[2][idi][j][idk] * inv_rho_j;
                  const dfloat w_j = s_Q[3][idi][j][idk] * inv_rho_j;	  
                  const dfloat E_j = s_Q[4][idi][j][idk];	  
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
                  
                  const dfloat Dij = s_D[jj][j]; // ii,jj = which line of nodes
                  
                  const dfloat Dx = Dij * .5f*(gxi + gxj);
                  const dfloat Dy = Dij * .5f*(gyi + gyj);
                  const dfloat Dz = Dij * .5f*(gzi + gzj);	  

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                  
                  val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
                  val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
                  val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
                  val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
                  val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];
                }

                // ============ accum rst = +/- 1 faces, nhat = -/+ 1
                
                // rotate coordinates
                // s 
                idi = jj;  idj = ii;  idk = kk;
                for (int ff = 0; ff < 2; ++ff){
                  const int f = 2+ff; 
                  const dfloat rho_j = s_Qf[0][f][idj][idk];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
                  const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
                  const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
                  const dfloat E_j = s_Qf[4][f][idj][idk];
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

                  // left vs right face normal vector, index	    
                  const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
                  const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

                  const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
                  const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
                  const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
                  const dfloat Lx = nsgn * geox * s_Lf[lid];
                  const dfloat Ly = nsgn * geoy * s_Lf[lid];
                  const dfloat Lz = nsgn * geoz * s_Lf[lid];

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                
                  val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
                  val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
                  val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
                  val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
                  val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

                }
                int id = tid + e*p_Nq3*p_Nfields;
                atomicAdd(&(rhs[id]), val[0]); id += p_Nq3;
                atomicAdd(&(rhs[id]), val[1]); id += p_Nq3;
                atomicAdd(&(rhs[id]), val[2]); id += p_Nq3;
                atomicAdd(&(rhs[id]), val[3]); id += p_Nq3;
                atomicAdd(&(rhs[id]), val[4]);
            }
        } else if(i < NUM_THREADS-p_NfpNfaces) {
            for(int tid=(i-2*thread_step); tid < p_Nq3; tid=tid+thread_step) {
// Dim 2
                // recompute IJK (occa issue)
                kk = tid / p_Nq2; // z-id
                ii = (tid - kk*p_Nq2) / p_Nq1; // y-id
                jj = tid % p_Nq1; // x-id
                
                dfloat val[p_Nfields] = {0};

                const dfloat rho_i = s_Q[0][ii][jj][kk];
                const dfloat inv_rho_i = 1.f/rho_i;
                const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
                const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
                const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
                const dfloat E_i = s_Q[4][ii][jj][kk];
                const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

                // start loop over dimensions		
                dfloat gxi,gyi,gzi;
                int idi,idj,idk,idout;

                const int geoid = 6;	
                idi = ii;  idj = jj;  idk = kk;
                
                // diff in "dim" direction
                gxi = s_G[geoid][ii][jj][kk];
                gyi = s_G[geoid+1][ii][jj][kk];
                gzi = s_G[geoid+2][ii][jj][kk];

                dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

                // differentiate w.r.t one coordinate
                for (int j = 0; j < p_Nq1; ++j){
                //      idk = j;  idout = kk;
                      
                  const dfloat gxj = s_G[geoid][idi][idj][j];
                  const dfloat gyj = s_G[geoid+1][idi][idj][j];
                  const dfloat gzj = s_G[geoid+2][idi][idj][j];	  
                  
                  const dfloat rho_j = s_Q[0][idi][idj][j];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Q[1][idi][idj][j] * inv_rho_j;
                  const dfloat v_j = s_Q[2][idi][idj][j] * inv_rho_j;
                  const dfloat w_j = s_Q[3][idi][idj][j] * inv_rho_j;	  
                  const dfloat E_j = s_Q[4][idi][idj][j];	  
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
                  
                  const dfloat Dij = s_D[kk][j]; // ii,jj = which line of nodes
                  
                  const dfloat Dx = Dij * .5f*(gxi + gxj);
                  const dfloat Dy = Dij * .5f*(gyi + gyj);
                  const dfloat Dz = Dij * .5f*(gzi + gzj);	  

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                  
                  val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
                  val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
                  val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
                  val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
                  val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

                }

                // ============ accum rst = +/- 1 faces, nhat = -/+ 1
                
                // rotate coordinates
                // t 
                idi = kk;  idj = ii;  idk = jj;
                for (int ff = 0; ff < 2; ++ff){
                  const int f = 4+ff; 
                  const dfloat rho_j = s_Qf[0][f][idj][idk];
                  const dfloat inv_rho_j = 1.f/rho_j;
                  const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
                  const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
                  const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
                  const dfloat E_j = s_Qf[4][f][idj][idk];
                  const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

                  // left vs right face normal vector, index	    
                  const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
                  const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

                  const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
                  const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
                  const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
                  const dfloat Lx = nsgn * geox * s_Lf[lid];
                  const dfloat Ly = nsgn * geoy * s_Lf[lid];
                  const dfloat Lz = nsgn * geoz * s_Lf[lid];

                  euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
                
                  val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
                  val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
                  val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
                  val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
                  val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

                }

                int rhsid = tid + e*p_Nq3*p_Nfields;
                atomicAdd(&(rhs[rhsid]), val[0]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[1]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[2]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[3]); rhsid += p_Nq3;
                atomicAdd(&(rhs[rhsid]), val[4]); 
            }
        } else if(i < NUM_THREADS) {
// Face computation
            const int tid = i - (NUM_THREADS-p_NfpNfaces);
            const int f = tid / p_Nfp;
            const int fid = tid % p_Nfp;
            const int fid1 = fid / p_Nq1;
            const int fid2 = fid % p_Nq1;

            dfloat val[p_Nfields] = {0};

            // compute (nhat*Vf).*FS contribution -> rhsf
            const dfloat rho_i = s_Qf[0][f][fid1][fid2];
            const dfloat invrho_i = 1.f/rho_i;
            const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
            const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
            const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
            const dfloat E_i = s_Qf[4][f][fid1][fid2];
            const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

            dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
            for (int j = 0; j < p_Nq1; ++j){

              int idi, idj, idk, geoid;
              if (f==0 || f==1){ 
                idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
              }else if (f==2 || f==3){ 
                idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
              }else if (f==4 || f==5){ 
                idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
              }
              const int is_left_face = (f % 2 == 0);
              const dfloat nsgn = is_left_face ? -1.f : 1.f;
              const int jid = is_left_face ? j : p_Nq1-j-1;
              const dfloat Vfj = .5f * nsgn * s_Vf[jid];
              
              const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
              const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
              const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    

              const dfloat rho_j = s_Q[0][idi][idj][idk];
              const dfloat invrho_j = 1.f/rho_j;
              const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
              const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
              const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
              const dfloat E_j = s_Q[4][idi][idj][idk];
              const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
              euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                     E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
              
              val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
              val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
              val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
              val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
              val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

            }

            int id = tid + e*p_NfpNfaces*p_Nfields;
            rhsf[id] = -val[0]; id += p_NfpNfaces;
            rhsf[id] = -val[1]; id += p_NfpNfaces;
            rhsf[id] = -val[2]; id += p_NfpNfaces;
            rhsf[id] = -val[3]; id += p_NfpNfaces;
            rhsf[id] = -val[4]; 
//            atomicAdd(&(rhsf[id]), -val[0]); id += p_NfpNfaces;
//            atomicAdd(&(rhsf[id]), -val[1]); id += p_NfpNfaces;
//            atomicAdd(&(rhsf[id]), -val[2]); id += p_NfpNfaces;
//            atomicAdd(&(rhsf[id]), -val[3]); id += p_NfpNfaces;
//            atomicAdd(&(rhsf[id]), -val[4]); id += p_NfpNfaces;
        }
    }
*/
/*
    Reduces computation to roughly log(p_Nq1) across 3 dimensions but uses
    shared memory. Shared memory usage limits order to below 5 or 6.
    Currently working on warp shuffle to speed up data movement and remove
    extra shared memory usage.
*/

//    for (int i = 0; i < 3*p_Nq3 + p_NfpNfaces; ++i; @inner(0)){
    for (int i = 0; i < 3*p_Nq3; ++i; @inner(0)){

      // Dim 0
      if(i < p_Nq3) {
        // recompute IJK (occa issue)
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id
        
        dfloat val[p_Nfields] = {0};

        const dfloat rho_i = s_Q[0][ii][jj][kk];
        const dfloat inv_rho_i = 1.f/rho_i;
        const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
        const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
        const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
        const dfloat E_i = s_Q[4][ii][jj][kk];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        // start loop over dimensions		
        dfloat gxi,gyi,gzi;
        int idi,idj,idk,idout;

        const int geoid = 0;	
        idi = ii;  idj = jj;  idk = kk;
        
        // diff in "dim" direction
        gxi = s_G[geoid][ii][jj][kk];
        gyi = s_G[geoid+1][ii][jj][kk];
        gzi = s_G[geoid+2][ii][jj][kk];

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

//@barrier("localMemFence");

        // differentiate w.r.t one coordinate
        for (int j = 0; j <= p_Nq1/2; ++j) {
          idi = (ii + j) % p_Nq1;  idout = ii;
          
          const dfloat gxj = s_G[geoid][idi][idj][idk];
          const dfloat gyj = s_G[geoid+1][idi][idj][idk];
          const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];	  
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          
          const dfloat Dij = s_D[idout][idi]; // ii,jj = which line of nodes
          
          const dfloat Dx = Dij * .5f*(gxi + gxj);
          const dfloat Dy = Dij * .5f*(gyi + gyj);
          const dfloat Dz = Dij * .5f*(gzi + gzj);	  

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
          val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
          val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
          val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
          val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

          if(!(!(p_Nq1 % 2) && (j==p_Nq1/2))) {
            const dfloat Dij2 = s_D[idi][idout];
            const dfloat Dx2 = Dij2 * .5f*(gxi + gxj);
            const dfloat Dy2 = Dij2 * .5f*(gyi + gyj);
            const dfloat Dz2 = Dij2 * .5f*(gzi + gzj);	  

            dfloat value0 = Dx2 * FxS[0] + Dy2 * FyS[0] + Dz2 * FzS[0];
            dfloat value1 = Dx2 * FxS[1] + Dy2 * FyS[1] + Dz2 * FzS[1];
            dfloat value2 = Dx2 * FxS[2] + Dy2 * FyS[2] + Dz2 * FzS[2];
            dfloat value3 = Dx2 * FxS[3] + Dy2 * FyS[3] + Dz2 * FzS[3];
            dfloat value4 = Dx2 * FxS[4] + Dy2 * FyS[4] + Dz2 * FzS[4];
/*            
            const int src_id = ((i%p_Nq1) + p_Nq1 - j) % p_Nq1;
            dfloat temp0 = __shfl_sync(0xffffffff, value0, src_id, p_Nq1);
            dfloat temp1 = __shfl_sync(0xffffffff, value1, src_id, p_Nq1);
            dfloat temp2 = __shfl_sync(0xffffffff, value2, src_id, p_Nq1);
            dfloat temp3 = __shfl_sync(0xffffffff, value3, src_id, p_Nq1);
            dfloat temp4 = __shfl_sync(0xffffffff, value4, src_id, p_Nq1);
if(e==0 && i < p_Nq1) {
printf("thread: %d Computed: %f sent to: %d received: %f from: %d\n", i, value0, (i+j)%p_Nq1, temp0, src_id);
}
//            dfloat temp0 = __shfl_down_sync(0xffffffff, value0, j, 4);
//            dfloat temp1 = __shfl_down_sync(0xffffffff, value1, j, 4);
//            dfloat temp2 = __shfl_down_sync(0xffffffff, value2, j, 4);
//            dfloat temp3 = __shfl_down_sync(0xffffffff, value3, j, 4);
//            dfloat temp4 = __shfl_down_sync(0xffffffff, value4, j, 4);

            val[0] += temp0;
            val[1] += temp1;
            val[2] += temp2;
            val[3] += temp3;
            val[4] += temp4;
*/

//if((temp0 == value0) && (temp1 == value1) && (temp2 == value2) && (temp3 == value3) && (temp4 == value4)) {
            atomicAdd(&(s_store_x[0][idi][jj][kk]), value0);
            atomicAdd(&(s_store_x[1][idi][jj][kk]), value1);
            atomicAdd(&(s_store_x[2][idi][jj][kk]), value2);
            atomicAdd(&(s_store_x[3][idi][jj][kk]), value3);
            atomicAdd(&(s_store_x[4][idi][jj][kk]), value4);
//}

          }
        }

        @barrier("localMemFence");
        val[0] += s_store_x[0][ii][jj][kk];
        val[1] += s_store_x[1][ii][jj][kk];
        val[2] += s_store_x[2][ii][jj][kk];
        val[3] += s_store_x[3][ii][jj][kk];
        val[4] += s_store_x[4][ii][jj][kk];

        // ============ accum rst = +/- 1 faces, nhat = -/+ 1
        
        // rotate coordinates
        // r
        idi = ii;  idj = jj;  idk = kk;
        for (int ff = 0; ff < 2; ++ff){
          const int f = ff; 
          const dfloat rho_j = s_Qf[0][f][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
          const dfloat E_j = s_Qf[4][f][idj][idk];
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

          // left vs right face normal vector, index	    
          const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
          const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

          const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
          const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
          const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
          const dfloat Lx = nsgn * geox * s_Lf[lid];
          const dfloat Ly = nsgn * geoy * s_Lf[lid];
          const dfloat Lz = nsgn * geoz * s_Lf[lid];

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
        
          val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
          val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
          val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
          val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
          val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

        }

        int id = i + e*p_Nq3*p_Nfields;
        atomicAdd(&(rhs[id]), val[0]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[1]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[2]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[3]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[4]); id += p_Nq3;

        if(i < (p_NfpNfaces/3)) {
          const int f = i / p_Nfp;
          const int fid = i % p_Nfp;
          const int fid1 = fid / p_Nq1;
          const int fid2 = fid % p_Nq1;

          dfloat val[p_Nfields] = {0};

          // compute (nhat*Vf).*FS contribution -> rhsf
          const dfloat rho_i = s_Qf[0][f][fid1][fid2];
          const dfloat invrho_i = 1.f/rho_i;
          const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
          const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
          const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
          const dfloat E_i = s_Qf[4][f][fid1][fid2];
          const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
          for (int j = 0; j < p_Nq1; ++j){

            int idi, idj, idk, geoid;
            if (f==0 || f==1){ 
              idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
            }else if (f==2 || f==3){ 
              idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
            }else if (f==4 || f==5){ 
              idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
            }
            const int is_left_face = (f % 2 == 0);
            const dfloat nsgn = is_left_face ? -1.f : 1.f;
            const int jid = is_left_face ? j : p_Nq1-j-1;
            const dfloat Vfj = .5f * nsgn * s_Vf[jid];
            
            const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
            const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
            const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    
            
            const dfloat rho_j = s_Q[0][idi][idj][idk];
            const dfloat invrho_j = 1.f/rho_j;
            const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
            const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
            const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
            const dfloat E_j = s_Q[4][idi][idj][idk];
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
            euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
            val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
            val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
            val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
            val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

          }

          int id = i + e*p_NfpNfaces*p_Nfields;
          atomicAdd(&(rhsf[id]), -val[0]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[1]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[2]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[3]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[4]); id += p_NfpNfaces;
        }

      } else if (i < 2*p_Nq3) {
      // Dim 1
        // recompute IJK (occa issue)
        kk = (i - p_Nq3) / p_Nq2; // z-id
        ii = (i - p_Nq3 - kk*p_Nq2) / p_Nq1; // y-id
        jj = (i - p_Nq3) % p_Nq1; // x-id
        
        dfloat val[p_Nfields] = {0};

        const dfloat rho_i = s_Q[0][ii][jj][kk];
        const dfloat inv_rho_i = 1.f/rho_i;
        const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
        const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
        const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
        const dfloat E_i = s_Q[4][ii][jj][kk];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        // start loop over dimensions		
        dfloat gxi,gyi,gzi;
        int idi,idj,idk,idout;

        const int geoid = 3;	
        idi = ii;  idj = jj;  idk = kk;
        
        // diff in "dim" direction
        gxi = s_G[geoid][ii][jj][kk];
        gyi = s_G[geoid+1][ii][jj][kk];
        gzi = s_G[geoid+2][ii][jj][kk];

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

        // differentiate w.r.t one coordinate
        for (int j = 0; j <= p_Nq1/2; ++j) {
          idj = (jj + j) % p_Nq1;  idout = jj;
          
          const dfloat gxj = s_G[geoid][idi][idj][idk];
          const dfloat gyj = s_G[geoid+1][idi][idj][idk];
          const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];	  
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          
          const dfloat Dij = s_D[idout][idj]; // ii,jj = which line of nodes
          
          const dfloat Dx = Dij * .5f*(gxi + gxj);
          const dfloat Dy = Dij * .5f*(gyi + gyj);
          const dfloat Dz = Dij * .5f*(gzi + gzj);	  

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);

          val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
          val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
          val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
          val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
          val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

//@barrier("localMemFence");
if(!(!(p_Nq1 % 2) && (j==p_Nq1/2))) {
const dfloat Dij2 = s_D[idj][idout];
const dfloat Dx2 = Dij2 * .5f*(gxi + gxj);
const dfloat Dy2 = Dij2 * .5f*(gyi + gyj);
const dfloat Dz2 = Dij2 * .5f*(gzi + gzj);	  

            dfloat value0 = Dx2 * FxS[0] + Dy2 * FyS[0] + Dz2 * FzS[0];
            dfloat value1 = Dx2 * FxS[1] + Dy2 * FyS[1] + Dz2 * FzS[1];
            dfloat value2 = Dx2 * FxS[2] + Dy2 * FyS[2] + Dz2 * FzS[2];
            dfloat value3 = Dx2 * FxS[3] + Dy2 * FyS[3] + Dz2 * FzS[3];
            dfloat value4 = Dx2 * FxS[4] + Dy2 * FyS[4] + Dz2 * FzS[4];
            
            const int src_id = ((i%p_Nq1) + p_Nq1 - j) % p_Nq1;
            dfloat temp0 = __shfl_sync(0xffffffff, value0, src_id, p_Nq1);
            dfloat temp1 = __shfl_sync(0xffffffff, value1, src_id, p_Nq1);
            dfloat temp2 = __shfl_sync(0xffffffff, value2, src_id, p_Nq1);
            dfloat temp3 = __shfl_sync(0xffffffff, value3, src_id, p_Nq1);
            dfloat temp4 = __shfl_sync(0xffffffff, value4, src_id, p_Nq1);
if(e==0 && i-p_Nq3 < p_Nq1) {
printf("thread: %d Computed: %f sent to: %d received: %f from: %d\n", i, value0, (i+j)%p_Nq1, temp0, src_id);
}

            val[0] += temp0;
            val[1] += temp1;
            val[2] += temp2;
            val[3] += temp3;
            val[4] += temp4;

/*
atomicAdd(&(s_store_y[0][ii][idj][kk]), Dx2 * FxS[0] + Dy2 * FyS[0] + Dz2 * FzS[0]);
atomicAdd(&(s_store_y[1][ii][idj][kk]), Dx2 * FxS[1] + Dy2 * FyS[1] + Dz2 * FzS[1]);
atomicAdd(&(s_store_y[2][ii][idj][kk]), Dx2 * FxS[2] + Dy2 * FyS[2] + Dz2 * FzS[2]);
atomicAdd(&(s_store_y[3][ii][idj][kk]), Dx2 * FxS[3] + Dy2 * FyS[3] + Dz2 * FzS[3]);
atomicAdd(&(s_store_y[4][ii][idj][kk]), Dx2 * FxS[4] + Dy2 * FyS[4] + Dz2 * FzS[4]);
*/
}

        }

/*
@barrier("localMemFence");
val[0] += s_store_y[0][ii][jj][kk];
val[1] += s_store_y[1][ii][jj][kk];
val[2] += s_store_y[2][ii][jj][kk];
val[3] += s_store_y[3][ii][jj][kk];
val[4] += s_store_y[4][ii][jj][kk];
*/
        // ============ accum rst = +/- 1 faces, nhat = -/+ 1
        
        // rotate coordinates
        // s 
        idi = jj;  idj = ii;  idk = kk;
        for (int ff = 0; ff < 2; ++ff){
          const int f = 2+ff; 
          const dfloat rho_j = s_Qf[0][f][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
          const dfloat E_j = s_Qf[4][f][idj][idk];
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

          // left vs right face normal vector, index	    
          const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
          const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

          const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
          const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
          const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
          const dfloat Lx = nsgn * geox * s_Lf[lid];
          const dfloat Ly = nsgn * geoy * s_Lf[lid];
          const dfloat Lz = nsgn * geoz * s_Lf[lid];

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
        
          val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
          val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
          val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
          val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
          val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

        }

@barrier("localMemFence");

        int id = i - p_Nq3 + e*p_Nq3*p_Nfields;
        atomicAdd(&(rhs[id]), val[0]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[1]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[2]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[3]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[4]);

        if(i < p_Nq3 + (p_NfpNfaces/3)) {
          const int f = (i - p_Nq3 + (p_NfpNfaces/3)) / p_Nfp;
          const int fid = (i - p_Nq3 + (p_NfpNfaces/3)) % p_Nfp;
          const int fid1 = fid / p_Nq1;
          const int fid2 = fid % p_Nq1;

          dfloat val[p_Nfields] = {0};

          // compute (nhat*Vf).*FS contribution -> rhsf
          const dfloat rho_i = s_Qf[0][f][fid1][fid2];
          const dfloat invrho_i = 1.f/rho_i;
          const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
          const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
          const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
          const dfloat E_i = s_Qf[4][f][fid1][fid2];
          const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
          for (int j = 0; j < p_Nq1; ++j){

            int idi, idj, idk, geoid;
            if (f==0 || f==1){ 
              idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
            }else if (f==2 || f==3){ 
              idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
            }else if (f==4 || f==5){ 
              idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
            }
            const int is_left_face = (f % 2 == 0);
            const dfloat nsgn = is_left_face ? -1.f : 1.f;
            const int jid = is_left_face ? j : p_Nq1-j-1;
            const dfloat Vfj = .5f * nsgn * s_Vf[jid];
            
            const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
            const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
            const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    
            
            const dfloat rho_j = s_Q[0][idi][idj][idk];
            const dfloat invrho_j = 1.f/rho_j;
            const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
            const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
            const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
            const dfloat E_j = s_Q[4][idi][idj][idk];
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
            euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
            val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
            val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
            val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
            val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

          }

          int id = i - p_Nq3 + (p_NfpNfaces/3) + e*p_NfpNfaces*p_Nfields;
          atomicAdd(&(rhsf[id]), -val[0]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[1]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[2]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[3]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[4]); id += p_NfpNfaces;
        }

      } else if(i < 3*p_Nq3) {
      // Dim 2
        // recompute IJK (occa issue)
        kk = (i - 2*p_Nq3) / p_Nq2; // z-id
        ii = (i - 2*p_Nq3 - kk*p_Nq2) / p_Nq1; // y-id
        jj = (i - 2*p_Nq3) % p_Nq1; // x-id
        
        dfloat val[p_Nfields] = {0};

        const dfloat rho_i = s_Q[0][ii][jj][kk];
        const dfloat inv_rho_i = 1.f/rho_i;
        const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
        const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
        const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
        const dfloat E_i = s_Q[4][ii][jj][kk];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        // start loop over dimensions		
        dfloat gxi,gyi,gzi;
        int idi,idj,idk,idout;

        const int geoid = 6;	
        idi = ii;  idj = jj;  idk = kk;
        
        // diff in "dim" direction
        gxi = s_G[geoid][ii][jj][kk];
        gyi = s_G[geoid+1][ii][jj][kk];
        gzi = s_G[geoid+2][ii][jj][kk];

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

        // differentiate w.r.t one coordinate
        for (int j = 0; j <= p_Nq1/2; ++j) {
          idk = (kk + j) % p_Nq1;  idout = kk;
          
          const dfloat gxj = s_G[geoid][idi][idj][idk];
          const dfloat gyj = s_G[geoid+1][idi][idj][idk];
          const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];	  
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          
          const dfloat Dij = s_D[idout][idk]; // ii,jj = which line of nodes
          
          const dfloat Dx = Dij * .5f*(gxi + gxj);
          const dfloat Dy = Dij * .5f*(gyi + gyj);
          const dfloat Dz = Dij * .5f*(gzi + gzj);	  

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
          val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
          val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
          val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
          val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

if(!(!(p_Nq1 % 2) && (j==p_Nq1/2))) {
const dfloat Dij2 = s_D[idk][idout];
const dfloat Dx2 = Dij2 * .5f*(gxi + gxj);
const dfloat Dy2 = Dij2 * .5f*(gyi + gyj);
const dfloat Dz2 = Dij2 * .5f*(gzi + gzj);	  

atomicAdd(&(s_store_z[0][ii][jj][idk]), Dx2 * FxS[0] + Dy2 * FyS[0] + Dz2 * FzS[0]);
atomicAdd(&(s_store_z[1][ii][jj][idk]), Dx2 * FxS[1] + Dy2 * FyS[1] + Dz2 * FzS[1]);
atomicAdd(&(s_store_z[2][ii][jj][idk]), Dx2 * FxS[2] + Dy2 * FyS[2] + Dz2 * FzS[2]);
atomicAdd(&(s_store_z[3][ii][jj][idk]), Dx2 * FxS[3] + Dy2 * FyS[3] + Dz2 * FzS[3]);
atomicAdd(&(s_store_z[4][ii][jj][idk]), Dx2 * FxS[4] + Dy2 * FyS[4] + Dz2 * FzS[4]);

}

        }
@barrier("localMemFence");
val[0] += s_store_z[0][ii][jj][kk];
val[1] += s_store_z[1][ii][jj][kk];
val[2] += s_store_z[2][ii][jj][kk];
val[3] += s_store_z[3][ii][jj][kk];
val[4] += s_store_z[4][ii][jj][kk];

        // ============ accum rst = +/- 1 faces, nhat = -/+ 1
        
        // rotate coordinates
        // t 
        idi = kk;  idj = ii;  idk = jj;
        for (int ff = 0; ff < 2; ++ff){
          const int f = 4+ff; 
          const dfloat rho_j = s_Qf[0][f][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
          const dfloat E_j = s_Qf[4][f][idj][idk];
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

          // left vs right face normal vector, index	    
          const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
          const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

          const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
          const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
          const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
          const dfloat Lx = nsgn * geox * s_Lf[lid];
          const dfloat Ly = nsgn * geoy * s_Lf[lid];
          const dfloat Lz = nsgn * geoz * s_Lf[lid];

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
        
          val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
          val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
          val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
          val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
          val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

        }

        int id = i - 2*p_Nq3 + e*p_Nq3*p_Nfields;
        atomicAdd(&(rhs[id]), val[0]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[1]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[2]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[3]); id += p_Nq3;
        atomicAdd(&(rhs[id]), val[4]); id += p_Nq3;

        if(i < 2*p_Nq3 + (p_NfpNfaces/3)) {
          const int f = (i - 2*p_Nq3 + (2*p_NfpNfaces/3)) / p_Nfp;
          const int fid = (i - 2*p_Nq3 + (2*p_NfpNfaces/3)) % p_Nfp;
          const int fid1 = fid / p_Nq1;
          const int fid2 = fid % p_Nq1;

          dfloat val[p_Nfields] = {0};

          // compute (nhat*Vf).*FS contribution -> rhsf
          const dfloat rho_i = s_Qf[0][f][fid1][fid2];
          const dfloat invrho_i = 1.f/rho_i;
          const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
          const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
          const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
          const dfloat E_i = s_Qf[4][f][fid1][fid2];
          const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
          for (int j = 0; j < p_Nq1; ++j){

            int idi, idj, idk, geoid;
            if (f==0 || f==1){ 
              idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
            }else if (f==2 || f==3){ 
              idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
            }else if (f==4 || f==5){ 
              idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
            }
            const int is_left_face = (f % 2 == 0);
            const dfloat nsgn = is_left_face ? -1.f : 1.f;
            const int jid = is_left_face ? j : p_Nq1-j-1;
            const dfloat Vfj = .5f * nsgn * s_Vf[jid];
            
            const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
            const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
            const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    
            
            const dfloat rho_j = s_Q[0][idi][idj][idk];
            const dfloat invrho_j = 1.f/rho_j;
            const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
            const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
            const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
            const dfloat E_j = s_Q[4][idi][idj][idk];
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
            euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                   E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
            val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
            val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
            val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
            val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

          }

          int id = i - 2*p_Nq3 + (2*p_NfpNfaces/3) + e*p_NfpNfaces*p_Nfields;
          atomicAdd(&(rhsf[id]), -val[0]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[1]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[2]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[3]); id += p_NfpNfaces;
          atomicAdd(&(rhsf[id]), -val[4]); id += p_NfpNfaces;
        }
      } 
    }

#else
/* 
    Computes dimensions in serial but uses more threads to speedup computation.
    Will become register bound with higher orders.
*/
//    for (int i = 0; i < p_T; ++i; @inner(0)){
    for(int i=0; i < p_Nq3*p_Nq1; ++i; @inner(0)) {
      // load ops
      if (i < p_Nq1){
      	s_Lf[i] = Lf1D[i];
      	s_Vf[i] = Vf1D[i];
      }           
      if (i < p_Nq2){
      	const int id1 = i % p_Nq1;
      	const int id2 = i / p_Nq1;
      	s_D[id1][id2] = D1D[i]; // i < (N+1)^2 = size of D1D
      }
      
      if (i < p_Nq3){
		
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id

        // load geofacs
        int id = i + p_Nq3 * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_G[geo][ii][jj][kk] = vgeo[id];
          id += p_Nq3;
        }

        // load vol values
        id = i + p_Nq3 * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Q[fld][ii][jj][kk] = Q[id];
          id += p_Nq3;
        }
      }

      // load surface geo
      if (i < p_NfpNfaces){
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;
        
        int id = i + p_NfpNfaces * p_Nvgeo * e;
        for (int geo = 0; geo < p_Nvgeo; ++geo){
          s_Gf[geo][f][fid1][fid2] = vfgeo[id];
          id += p_NfpNfaces;
        }

        int idf = i + p_NfpNfaces * p_Nfields * e;
        for (int fld = 0; fld < p_Nfields; ++fld){
          s_Qf[fld][f][fid1][fid2] = Qf[idf];
          idf += p_NfpNfaces;
        }       
      }      

      if (i < p_Nq3){

        int id = i + e*p_Nq3*p_Nfields;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
        rhs[id] = 0.0f; id += p_Nq3;
      }

      if (i < p_NfpNfaces) {
        int id = i + e*p_NfpNfaces*p_Nfields;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
        rhsf[id] = 0.0f; id += p_NfpNfaces;
      }

      if(i < p_Nq3) {
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id
        storage[0][ii][jj][kk] = 0.0f;
        storage[1][ii][jj][kk] = 0.0f;
        storage[2][ii][jj][kk] = 0.0f;
        storage[3][ii][jj][kk] = 0.0f;
        storage[4][ii][jj][kk] = 0.0f;
      }
    }
@barrier("localMemFence");
/*
    Compute all interactions for each element in parallel and reduces
    values to single value. All elements are run in parallel. Will become
    thread/register limited for higher orders
*/
/*
    for (int i = 0; i < p_Nq3*p_Nq1; ++i; @inner(0)) {
      if (i < p_Nq3*p_Nq1) {
        int id = i / p_Nq1;
        dfloat val[p_Nfields] = {0};
        for( int dim = 0; dim < 3; ++dim) {
          kk = id / p_Nq2;
          ii = (id - kk * p_Nq2) / p_Nq1;
          jj = id % p_Nq1;

          const int j = i % p_Nq1;


          const dfloat rho_i = s_Q[0][ii][jj][kk];
          const dfloat inv_rho_i = 1.f/rho_i;
          const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
          const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
          const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
          const dfloat E_i = s_Q[4][ii][jj][kk];
          const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

          // start loop over dimensions		
          dfloat gxi,gyi,gzi;
          int idi,idj,idk,idout;

          const int geoid = 3*dim;
          idi = ii; idj = jj; idk = kk;
          
          // diff in "dim" direction
          gxi = s_G[geoid][ii][jj][kk];
          gyi = s_G[geoid+1][ii][jj][kk];
          gzi = s_G[geoid+2][ii][jj][kk];

          if (dim==0){
            idi = j;  idout = ii;
          }else if (dim==1){
            idj = j;  idout = jj;	  	      
          }else if (dim==2){
            idk = j;  idout = kk;
          }
          
          const dfloat gxj = s_G[geoid][idi][idj][idk];
          const dfloat gyj = s_G[geoid+1][idi][idj][idk];
          const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat inv_rho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];	  
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          
          const dfloat Dij = s_D[idout][j]; // ii,jj = which line of nodes
          
          const dfloat Dx = Dij * .5f*(gxi + gxj);
          const dfloat Dy = Dij * .5f*(gyi + gyj);
          const dfloat Dz = Dij * .5f*(gzi + gzj);	  

          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
           E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
          val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
          val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
          val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
          val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

          // ============ accum rst = +/- 1 faces, nhat = -/+ 1
          if(j == 0) {          
          // rotate coordinates
            if (dim==0){ // r
              idi = ii;  idj = jj;  idk = kk;
            }else if (dim==1){ // s 
              idi = jj;  idj = ii;  idk = kk;
            }else{ // t 
              idi = kk;  idj = ii;  idk = jj;
            }
            for (int ff = 0; ff < 2; ++ff){
              const int f = 2*dim+ff; 
              const dfloat rho_j = s_Qf[0][f][idj][idk];
              const dfloat inv_rho_j = 1.f/rho_j;
              const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
              const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
              const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
              const dfloat E_j = s_Qf[4][f][idj][idk];
              const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

              // left vs right face normal vector, index	    
              const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
              const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

              const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
              const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
              const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
              const dfloat Lx = nsgn * geox * s_Lf[lid];
              const dfloat Ly = nsgn * geoy * s_Lf[lid];
              const dfloat Lz = nsgn * geoz * s_Lf[lid];

              euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
               E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
              val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
              val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
              val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
              val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
              val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];
            }
          }        
        }

        atomicAdd(&(storage[0][ii][jj][kk]), val[0]);
        atomicAdd(&(storage[1][ii][jj][kk]), val[1]);
        atomicAdd(&(storage[2][ii][jj][kk]), val[2]);
        atomicAdd(&(storage[3][ii][jj][kk]), val[3]);
        atomicAdd(&(storage[4][ii][jj][kk]), val[4]);
@barrier("localMemFence");
        if(i < p_Nq3) {
          kk = i / p_Nq2;
          ii = (i - kk * p_Nq2) / p_Nq1;
          jj = i % p_Nq1;
          int id = i + e*p_Nq3*p_Nfields;
          rhs[id] = storage[0][ii][jj][kk]; id += p_Nq3;
          rhs[id] = storage[1][ii][jj][kk]; id += p_Nq3;
          rhs[id] = storage[2][ii][jj][kk]; id += p_Nq3;
          rhs[id] = storage[3][ii][jj][kk]; id += p_Nq3;	
          rhs[id] = storage[4][ii][jj][kk];
        }
      }
*/

/*
    Original form of computation
*/

    for (int i = 0; i < p_T; ++i; @inner(0)){
      if (i < p_Nq3){

        // recompute IJK (occa issue)
        kk = i / p_Nq2; // z-id
        ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        jj = i % p_Nq1; // x-id
        
        dfloat val[p_Nfields] = {0};

        const dfloat rho_i = s_Q[0][ii][jj][kk];
        const dfloat inv_rho_i = 1.f/rho_i;
        const dfloat u_i = s_Q[1][ii][jj][kk] * inv_rho_i;
        const dfloat v_i = s_Q[2][ii][jj][kk] * inv_rho_i;
        const dfloat w_i = s_Q[3][ii][jj][kk] * inv_rho_i;	
        const dfloat E_i = s_Q[4][ii][jj][kk];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        // start loop over dimensions		
        dfloat gxi,gyi,gzi;
        int idi,idj,idk,idout;
        for (int dim = 0; dim < 3; ++dim){
        
          const int geoid = 3*dim;	
          idi = ii;  idj = jj;  idk = kk;
          
          // diff in "dim" direction
          gxi = s_G[geoid][ii][jj][kk];
          gyi = s_G[geoid+1][ii][jj][kk];
          gzi = s_G[geoid+2][ii][jj][kk];

          dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];

          // differentiate w.r.t one coordinate
          for (int j = 0; j < p_Nq1; ++j){
            if (dim==0){
              idi = j;  idout = ii;
            }else if (dim==1){
              idj = j;  idout = jj;	  	      
            }else if (dim==2){
              idk = j;  idout = kk;
            }
            
            const dfloat gxj = s_G[geoid][idi][idj][idk];
            const dfloat gyj = s_G[geoid+1][idi][idj][idk];
            const dfloat gzj = s_G[geoid+2][idi][idj][idk];	  
            
            const dfloat rho_j = s_Q[0][idi][idj][idk];
            const dfloat inv_rho_j = 1.f/rho_j;
            const dfloat u_j = s_Q[1][idi][idj][idk] * inv_rho_j;
            const dfloat v_j = s_Q[2][idi][idj][idk] * inv_rho_j;
            const dfloat w_j = s_Q[3][idi][idj][idk] * inv_rho_j;	  
            const dfloat E_j = s_Q[4][idi][idj][idk];	  
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
           
            const dfloat Dij = s_D[idout][j]; // ii,jj = which line of nodes
            
            const dfloat Dx = Dij * .5f*(gxi + gxj);
            const dfloat Dy = Dij * .5f*(gyi + gyj);
            const dfloat Dz = Dij * .5f*(gzi + gzj);	  

            euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
            
            val[0] += Dx * FxS[0] + Dy * FyS[0] + Dz * FzS[0];
            val[1] += Dx * FxS[1] + Dy * FyS[1] + Dz * FzS[1];
            val[2] += Dx * FxS[2] + Dy * FyS[2] + Dz * FzS[2];
            val[3] += Dx * FxS[3] + Dy * FyS[3] + Dz * FzS[3];
            val[4] += Dx * FxS[4] + Dy * FyS[4] + Dz * FzS[4];

          }

          // ============ accum rst = +/- 1 faces, nhat = -/+ 1
          
          // rotate coordinates
          if (dim==0){ // r
            idi = ii;  idj = jj;  idk = kk;
          }else if (dim==1){ // s 
            idi = jj;  idj = ii;  idk = kk;
          }else{ // t 
            idi = kk;  idj = ii;  idk = jj;
          }
          for (int ff = 0; ff < 2; ++ff){
            const int f = 2*dim+ff; 
            const dfloat rho_j = s_Qf[0][f][idj][idk];
            const dfloat inv_rho_j = 1.f/rho_j;
            const dfloat u_j = s_Qf[1][f][idj][idk] * inv_rho_j;
            const dfloat v_j = s_Qf[2][f][idj][idk] * inv_rho_j;
            const dfloat w_j = s_Qf[3][f][idj][idk] * inv_rho_j;	
            const dfloat E_j = s_Qf[4][f][idj][idk];
            const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);

            // left vs right face normal vector, index	    
            const dfloat nsgn = (ff==0) ? -1.f : 1.f; 
            const int lid = (ff==0) ? idi : p_Nq1-idi-1;  

            const dfloat geox = .5f * (s_G[geoid  ][ii][jj][kk] + s_Gf[geoid  ][f][idj][idk]);
            const dfloat geoy = .5f * (s_G[geoid+1][ii][jj][kk] + s_Gf[geoid+1][f][idj][idk]);
            const dfloat geoz = .5f * (s_G[geoid+2][ii][jj][kk] + s_Gf[geoid+2][f][idj][idk]);
            const dfloat Lx = nsgn * geox * s_Lf[lid];
            const dfloat Ly = nsgn * geoy * s_Lf[lid];
            const dfloat Lz = nsgn * geoz * s_Lf[lid];

            euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
             E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
            val[0] += Lx * FxS[0] + Ly * FyS[0] + Lz * FzS[0];
            val[1] += Lx * FxS[1] + Ly * FyS[1] + Lz * FzS[1];
            val[2] += Lx * FxS[2] + Ly * FyS[2] + Lz * FzS[2];
            val[3] += Lx * FxS[3] + Ly * FyS[3] + Lz * FzS[3];
            val[4] += Lx * FxS[4] + Ly * FyS[4] + Lz * FzS[4];

          }
        } // for dim < 3
        int id = i + e*p_Nq3*p_Nfields;
        rhs[id] = val[0]; id += p_Nq3;
        rhs[id] = val[1]; id += p_Nq3;
        rhs[id] = val[2]; id += p_Nq3;
        rhs[id] = val[3]; id += p_Nq3;	
        rhs[id] = val[4];
	
      } // i < p_Nq3      

      if (i < p_NfpNfaces){
	
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;

        dfloat val[p_Nfields] = {0};

        // compute (nhat*Vf).*FS contribution -> rhsf
        const dfloat rho_i = s_Qf[0][f][fid1][fid2];
        const dfloat invrho_i = 1.f/rho_i;
        const dfloat u_i = s_Qf[1][f][fid1][fid2] * invrho_i;
        const dfloat v_i = s_Qf[2][f][fid1][fid2] * invrho_i;
        const dfloat w_i = s_Qf[3][f][fid1][fid2] * invrho_i;	
        const dfloat E_i = s_Qf[4][f][fid1][fid2];
        const dfloat beta_i = beta(rho_i,u_i,v_i,w_i,E_i);

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];	
        for (int j = 0; j < p_Nq1; ++j){

          int idi, idj, idk, geoid;
          if (f==0 || f==1){ 
            idi = j;     idj = fid1;   idk = fid2;  geoid = 0; // r faces	    
          }else if (f==2 || f==3){ 
            idi = fid1;  idj = j;      idk = fid2;  geoid = 3; // s faces
          }else if (f==4 || f==5){ 
            idi = fid1;  idj = fid2;   idk = j;     geoid = 6; // t faces
          }
          const int is_left_face = (f % 2 == 0);
          const dfloat nsgn = is_left_face ? -1.f : 1.f;
          const int jid = is_left_face ? j : p_Nq1-j-1;
          const dfloat Vfj = .5f * nsgn * s_Vf[jid];
          
          const dfloat Vfx = (s_Gf[geoid+0][f][fid1][fid2] + s_G[geoid+0][idi][idj][idk]) * Vfj;
          const dfloat Vfy = (s_Gf[geoid+1][f][fid1][fid2] + s_G[geoid+1][idi][idj][idk]) * Vfj;
          const dfloat Vfz = (s_Gf[geoid+2][f][fid1][fid2] + s_G[geoid+2][idi][idj][idk]) * Vfj;	    
          
          const dfloat rho_j = s_Q[0][idi][idj][idk];
          const dfloat invrho_j = 1.f/rho_j;
          const dfloat u_j = s_Q[1][idi][idj][idk] * invrho_j;
          const dfloat v_j = s_Q[2][idi][idj][idk] * invrho_j;
          const dfloat w_j = s_Q[3][idi][idj][idk] * invrho_j;	  
          const dfloat E_j = s_Q[4][idi][idj][idk];
          const dfloat beta_j = beta(rho_j,u_j,v_j,w_j,E_j);
          euler3d_flux_test(rho_i, rho_j, u_i, u_j, v_i, v_j, w_i, w_j,
                 E_i, E_j, beta_i, beta_j, FxS, FyS, FzS);
          
          val[0] += Vfx * FxS[0] + Vfy * FyS[0] + Vfz * FzS[0];
          val[1] += Vfx * FxS[1] + Vfy * FyS[1] + Vfz * FzS[1];
          val[2] += Vfx * FxS[2] + Vfy * FyS[2] + Vfz * FzS[2];
          val[3] += Vfx * FxS[3] + Vfy * FyS[3] + Vfz * FzS[3];
          val[4] += Vfx * FxS[4] + Vfy * FyS[4] + Vfz * FzS[4];	  	  

        }

        int id = i + e*p_NfpNfaces*p_Nfields;
        rhsf[id] = -val[0]; id += p_NfpNfaces;
        rhsf[id] = -val[1]; id += p_NfpNfaces;
        rhsf[id] = -val[2]; id += p_NfpNfaces;
        rhsf[id] = -val[3]; id += p_NfpNfaces;	
        rhsf[id] = -val[4]; 	

      }
   	        
    }// inner0

#endif
  }
}

@kernel void surface(const int K,
		     const dfloat * vgeo,
		     const dfloat * fgeo,		     
		     const int    * mapPq,		     
		     const dfloat * Lf1D,
		     const dfloat * Qf,
		     const dfloat * rhsf,
		     dfloat * rhs){

  for (int e = 0; e < K; ++e; @outer(0)){

    @shared dfloat s_fnS[p_Nfields][p_Nfaces][p_Nq1][p_Nq1];
    @shared dfloat s_Lf[p_Nq1];
    
    for (int i = 0; i < p_T; ++i; @inner(0)){

      if (i < p_Nq1){
      	s_Lf[i] = Lf1D[i];
      }

      if (i < p_NfpNfaces){

        int idM = i + e*p_Nfields*p_NfpNfaces;
        int idP = mapPq[i + e*p_NfpNfaces];

        //printf("idM = %d, idP = %d\n",idM,idP);

        // load +/- values
        const dfloat rhoM = Qf[idM];   idM += p_NfpNfaces;
        const dfloat rhouM = Qf[idM];  idM += p_NfpNfaces;
        const dfloat rhovM = Qf[idM];  idM += p_NfpNfaces;
        const dfloat rhowM = Qf[idM];  idM += p_NfpNfaces;	
        const dfloat EM = Qf[idM];
        
        const dfloat rhoP = Qf[idP];   idP += p_NfpNfaces;
        const dfloat rhouP = Qf[idP];  idP += p_NfpNfaces;
        const dfloat rhovP = Qf[idP];  idP += p_NfpNfaces;
        const dfloat rhowP = Qf[idP];  idP += p_NfpNfaces;	
        const dfloat EP = Qf[idP];

        const dfloat invrhoM = 1.f/rhoM; 
        const dfloat invrhoP = 1.f/rhoP; 
        const dfloat uM = rhouM*invrhoM;
        const dfloat vM = rhovM*invrhoM;
        const dfloat wM = rhowM*invrhoM;	
        const dfloat uP = rhouP*invrhoP;	
        const dfloat vP = rhovP*invrhoP;
        const dfloat wP = rhowP*invrhoP;      	
        const dfloat betaM = beta(rhoM,uM,vM,wM,EM);
        const dfloat betaP = beta(rhoP,uP,vP,wP,EP);      

        dfloat FxS[p_Nfields],FyS[p_Nfields],FzS[p_Nfields];
        euler3d_flux(rhoM,rhoP,
               uM,uP,vM,vP,wM,wP,
               EM,EP,betaM,betaP,
               FxS,FyS,FzS);

        const int idf = i + e*p_NfpNfaces*p_Nfgeo;
        const dfloat nxJ = fgeo[idf];
        const dfloat nyJ = fgeo[idf + p_NfpNfaces];
        const dfloat nzJ = fgeo[idf + 2*p_NfpNfaces];	
        const dfloat sJ  = fgeo[idf + 3*p_NfpNfaces];	
        
        const int f = i / p_Nfp;
        const int fid = i % p_Nfp;
        const int fid1 = fid / p_Nq1;
        const int fid2 = fid % p_Nq1;

        idM = i + e*p_NfpNfaces*p_Nfields;

        const dfloat unormM = (uM*uM + vM*vM + wM*wM);
        const dfloat unormP = (uP*uP + vP*vP + wP*wP);	
        const dfloat pM = (p_gamma-1.f)*(EM - .5f*rhoM*unormM);
        const dfloat pP = (p_gamma-1.f)*(EP - .5f*rhoP*unormP);	
        const dfloat cvelM = sqrt(p_gamma*pM/rhoM);
        const dfloat cvelP = sqrt(p_gamma*pP/rhoP);	
        const dfloat LFc = fmax(sqrt(unormM) + cvelM, sqrt(unormP) + cvelP);	
        const dfloat Lfscale = .5f*p_tau*LFc*sJ;
        
        const dfloat FnS1 = FxS[0]*nxJ + FyS[0]*nyJ + FzS[0]*nzJ - Lfscale*(rhoP-rhoM);
        const dfloat FnS2 = FxS[1]*nxJ + FyS[1]*nyJ + FzS[1]*nzJ - Lfscale*(rhouP-rhouM);
        const dfloat FnS3 = FxS[2]*nxJ + FyS[2]*nyJ + FzS[2]*nzJ - Lfscale*(rhovP-rhovM);
        const dfloat FnS4 = FxS[3]*nxJ + FyS[3]*nyJ + FzS[3]*nzJ - Lfscale*(rhowP-rhowM);	
        const dfloat FnS5 = FxS[4]*nxJ + FyS[4]*nyJ + FzS[4]*nzJ - Lfscale*(EP-EM);
        s_fnS[0][f][fid1][fid2] = FnS1 + rhsf[idM]; idM += p_NfpNfaces;
        s_fnS[1][f][fid1][fid2] = FnS2 + rhsf[idM]; idM += p_NfpNfaces;
        s_fnS[2][f][fid1][fid2] = FnS3 + rhsf[idM]; idM += p_NfpNfaces;
        s_fnS[3][f][fid1][fid2] = FnS4 + rhsf[idM]; idM += p_NfpNfaces;	
        s_fnS[4][f][fid1][fid2] = FnS5 + rhsf[idM];

      } // i < NfpNfaces      
    }
    @barrier("localMemFence");

    // apply lift and inverse jacobian
    for (int i = 0; i < p_T; ++i; @inner(0)){

      if (i < p_Nq3){

        const dfloat Ji = vgeo[i + 9*p_Nq3 + e*p_Nvgeo*p_Nq3];
        const dfloat invJ = 1.f/Ji;
        //printf("Np = %d, J(%d) = %f\n",p_Nq3,i,Ji);

        const int kk = i / p_Nq2; // z-id
        const int ii = (i - kk*p_Nq2) / p_Nq1; // y-id
        const int jj = i % p_Nq1; // x-id
        
        // accumulate value per node
        int id = i + e*p_Nq3*p_Nfields;
        for (int fld = 0; fld < p_Nfields; ++fld){
          dfloat val = 0.f;
          
          // r = (-/+) 1 face contribution	  
          val += s_Lf[ii]*s_fnS[fld][0][jj][kk] + s_Lf[p_Nq1-ii-1]*s_fnS[fld][1][jj][kk];

          // s = (-/+) 1 face contribution
          val += s_Lf[jj]*s_fnS[fld][2][ii][kk] + s_Lf[p_Nq1-jj-1]*s_fnS[fld][3][ii][kk];

          // t = (-/+) 1 face contribution	  
          val += s_Lf[kk]*s_fnS[fld][4][ii][jj] + s_Lf[p_Nq1-kk-1]*s_fnS[fld][5][ii][jj];

          // maybe divide by J here?
          //rhs[id] = 1.0;
          rhs[id] = -(rhs[id] + val)*invJ;

          id += p_Nq3;
        }

      }//if 
    }//inner0

  }
}


@kernel void update(const int K,
		    const dfloat fa,
		    const dfloat fb,
		    const dfloat fdt,		    
		    dfloat * Q,
		    dfloat * rhs,
		    dfloat * res){

  for (int e = 0; e < K; ++e; @outer(0)){        
    
    for (int i = 0; i < p_Nq3; ++i; @inner(0)){
      
      // update vol values
      dfloat Qi[p_Nfields];
      int id = i + e*p_Nfields*p_Nq3;
      for(int fld = 0; fld < p_Nfields; ++fld){
	
        // load rhs, residual, solution
        const dfloat rhsi = rhs[id]; // make neg for rhs
        dfloat resi = res[id];
        Qi[fld] = Q[id];
        
        // update residual and solution
        resi = fa*resi + fdt*rhsi;	  
        Qi[fld] += fb*resi;
        
        // store updated residual and solution
        res[id] = resi;	  
        Q[id] = Qi[fld];
        
        id += p_Nq3;
      }
      
    }
  }
}

// compute auxiliary quantities
@kernel void compute_aux(const int K,
			 const dfloat * wJq,
			 const dfloat * Q,
			 dfloat *aux)
{
  for (int e = 0; e < K; ++e; @outer(0)){
    
    @shared dfloat sKE[p_ceilNq2];
    
    for (int i = 0; i < p_ceilNq2; ++i; @inner(0)){

      sKE[i] = 0.f;
      
      if (i < p_Nq3){
        const int id = i + e*p_Nq3*p_Nfields;
        const dfloat rho = Q[id + 0 * p_Nq3];
        const dfloat rhou = Q[id + 1 * p_Nq3];
        const dfloat rhov = Q[id + 2 * p_Nq3];
        const dfloat rhow = Q[id + 3 * p_Nq3];
        const dfloat E = Q[id + 4 * p_Nq3];
        const dfloat wJqi = wJq[i + e*p_Nq3];
        sKE[i] = .5f*(rhou*rhou + rhov*rhov + rhow*rhow)/rho * wJqi;
      }
    }
    @barrier("localMemFence");
    
    // slowish parallel reduction
    for (int sk = p_ceilNq2/2; sk > 0; sk/=2){
      for (int i = 0; i < p_ceilNq2; ++i; @inner(0)){
      	if (i < sk){
      	  sKE[i] +=  sKE[i + sk];
      	}
      }
      @barrier("localMemFence");
    }
    
    for (int i = 0; i < p_ceilNq2; ++i; @inner(0)){
      if (i==0){
      	aux[e] = sKE[0];
      }
    }
  }
}


